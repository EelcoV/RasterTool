Copyright (C) Eelco Vriezekolk, Universiteit Twente, Agentschap Telecom.
See LICENSE.md


In general, when object A has some B's, then the action will be in A to add a B, not on B to attach it to A. This applies to
-Components having Nodes,
-NodeClusters having Components,
-Projects having Services,
-Services having nodes.
-Projects having checklistitems.
The reverse, removing a B from an A, is the responsibility of B. Typically, when a B is destroyed, it will remove itself from its A.
==> Not always the case, e.g. Component.removenode()

With the transition towards transactions with undo/redo, the code for setting properties on objects needs to be rearranged as well.
Perhaps: use change<property> for methods that start a transaction, and set<property> for methods that immediately affect the object?


Actions
~~~~~~~
The following are atomic user-interface actions.

Node(s):
x- create(type,id,service)	[workspacedrophandler:]
x- connect					[Node.try_attach_center:]
x- duplicate				[initTabDiagrams: $('#mi_du').mouseup]
x- destroy(effect)			[initTabDiagrams: $('#mi_de').mouseup]
x- destroy selection		[initTabDiagrams: $('#mi_sd').mouseup]
x- changeType(type)			[initTabDiagrams: $('#mi_cttWLS').mouseup and 4 others]
x- rename(title)				[Node.paint: $('#titlemain'+this.id).editInPlace callback]
x- move single node			[Node.paint: $(this.jnid).draggable stop handler]
x- resize single node		[Node.pain:t $("#node"+this.id).resizable stop handler]
x- move selection			[Service.paintall: $('#selectrect').draggable stop handler]
x- move all nodes			[Node.paint: $(this.jnid).draggable]

Component:
x- class to single/mult.	[initTabDiagrams: $('#mi_sm').mouseup]
x- rename vuln				[ThreatAssessment.addtablerow_behavioronly: $("#dth_"+prefix+"name"+this.id).editInPlace callback]
x- setFrequency(vuln,freq)	[ThreatAssessment.addtablerow_behavioronly: $("#dth_"+prefix+"freq"+this.id).editInPlace callback]
x- setImpact(vuln,impact)	[ThreatAssessment.addtablerow_behavioronly: $("#dth_"+prefix+"impact"+this.id).editInPlace callback]
x- setRemark(vuln,remark)	[ThreatAssessment.addtablerow_behavioronly: $("#dth_"+prefix+"remark"+this.id).editInPlace callback]
x- paste					[displayComponentThreatAssessmentsDialog: $('#dthpastedia'+cid).click handler]
x- paste					[paintSingleFailures: function pastehandler]
x- removeVuln(vuln)			[ThreatAssessment.addtablerow_behavioronly: $("#dth_"+prefix+"del"+this.id).click]
x- addVuln					[displayComponentThreatAssessmentsDialog: $('#dthadddia'+cid).click handler]
x- addVuln					[paintSingleFailures: function addhandler]

NodeCluster:
- move node or cluster		[nodeClusterReorder: ("Create cluster", "Move node from cluster", "Remove cluster", "Move cluster")]
- rename cluster			[reallyRepaintCluster: $('.litext').editInPlace callback]
- set frequency				[as for Component]
- set impact				[as for Component]
- set remark				[as for Component]
Any change could cause clusters to be deleted and nodes to be moved, because of normalisation.

Project:
x- create(id)				[initLibraryPanel: $('#buttadd').click]
x- create(id)				[initLibraryPanel: $('#buttimport').click]
x- rename					[initLibraryPanel: $('#libprops').click "Change properties" button callback]
- destroy()					[initLibraryPanel: $('#buttdel').click]
x- share/make private		[initLibraryPanel: $('#libprops').click "Change properties" button callback]
x- edit labels				[showLabelEditForm]

ChecklistItems (Vulnerability)
x- add						[initTabDiagrams: function addhandler]
x- remove					[Vulnerability.addtablerow: $('#thdel'+this.id).click callback]
x- rename					[Vulnerability.addtablerow: $('#thname'+this.id).editInPlace callback]
x- change description 		[Vulnerability.addtablerow: $('#thdesc'+this.id).editInPlace callback]
x- paste					[initTabDiagrams: function pastehandler]

Service:
x- addService(service)		[initTabDiagrams: $('#servaddbuttondia').click]
x- addService(service)		[initTabSingleFs: $('#servaddbuttonsf').click]
x- destroy()				[bottomTabsCloseHandler:]
x- rename(title)			[diagramTabEditStart: "Change name" button callback]

Other:
Zap Library is not a UI action that changes a project.



January 2020
~~~~~~~~~~~~
Instead of sequential keys starting from 1, use 128 bit random keys (e.g. UUID).
This will, in practice, guarantee unique keys even across browsers/client computers.
No checks on uniqueness of keys is necessary in practice. The probability of a cosmic ray causing a bit flip is far higher than the probability of key collision.
Is there a benefit to using UUIDs instead of plain hexadecimal 128-bit random numbers?
A very good random number generator is necessary. Math.random() is insufficient, we must use crypto.getRandomValues().
Currently, loadFromString contains elaborate code to renumber keys to prevent collisions. This will no longer be necessary.
Whenever one browser posts an atomic change, that change can be included into another browser without rekeying.
If we build the code to save, stash and adopt such changes, we almost the the Undo function for free. The only extra requirement for an Undo is that each atomic change can be easily converted into its reverse.
Main disadvantage: yet another one-way upgrade (as we had when transitioning to version 3.0 of the tools).

Two browsers can simultaneously work on the same project. Different browsers have a separate instance of the same project.
Do we need the feature of simultaneous editing at all? Can we drop it?
The current implementation is clumsy, as the entire project is uploaded to the server, and pushed to fellow browsers who must do a full load-then-switch of the modified project.
It would be much more efficient to share atomic changes.
Because of network delays and interruption, we need to have a robust sync service, and queuing of possibly multiple actions.

Should one browser instance be able to Undo action made by another browser?
What if a browser receives some but not all actions, undoes the last of those, and then receive the remaining actions? Will the project still be in a consistent state? Not necessarily: suppose that the action that was undone was a Create Node action. Subsequent actions will likely refer to that node. This proves that only the last action can be safely undone.
A browser instance will never know whether it is up to date, or whether there are still atomic actions queued and undelivered. Therefore, Undo cannot be applied to actions received from other browsers.
So the answer must be that you can only Undo your own actions. The only way to avoid inconsistencies is to detect the situation, and offer the user to take the shared project private.

Alternatively, we can give each atomic action a timestamp, and order them sequentially.
When a browser receives atomic actions from another instance they are merged into this sequential list.
Any actions applied at a later time than the ones received will be undone, then the received actions are performed, then the undone actions will be retried.
Any action that fails is ignored (silently or with an error message).
What to do when network delays or interruptions last for a long time? Different instances will then slowly diverge.
How do we ensure that instances have roughly the same clock?
Currently, share.php uses the server's clock only, not the browsers' clocks.
We can apply a correction (drift) to the local clock, based on the server's clock.

The above may work, provided that all actions are undoable.
Are there actions that cannot be undone?
Difficult/impossible to undo:
- delete a selection
- delete a service
- delete a project
- zap, delete localstorage (probably not an action)
- actions on clusters that lead to normalisation?
At first glance all actions are *in principle* undoable.

In fact, even changing the title of a node proves to be complex (because renaming als creates/deletes node classes).

What to do with transactions when the user switches projects?
Switching projects is itself not a transaction (although undoable).
Switching projects can be useful in the workflow, to quickly check how that other project solved some issue.
Preserve? Then there must be a transaction list as property of each project. Or, transactions must have a project-id.
Reset: the easiest for now, but not the most user-friendly.
Let's see how the server sync of transactions works out, before deciding on this.

Also complex: creating a new node. Undo is easy: just delete the node.
Creating requires new ID for the node, often an ID for the component and IDs for its ThreatAssessment.
But also an ID for a node cluster *and* an ID for its ThreatAssessment.
Alternatively: provide each do_data and undo_data with a list of IDs to use, in case an ID is needed?
IDs to create a node:
 1 for the node
 1 for the component
 N for the threat assessments of the component
 N for the each root cluster
 N for the each cluster's threat assessment
--> 3N+2 IDs required. With 5 or 6 default vulnerabilities about 20 IDs are needed!
When we leave empty root clusters be instead of 'normalizing' them, to make this at least a bit easier?
It would then need only N+2 new IDs, which is what is needed for nodeTitle actions as well.

