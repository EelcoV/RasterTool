/* Copyright (C) Eelco Vriezekolk, Universiteit Twente, Agentschap Telecom.
 * See LICENSE.md
 */

/* globals
bugreport, createUUID, isSameString, newRasterConfirm, nid2id, rasterAlert, _, _H, AssessmentIterator, Component, H, LS, NodeClusterIterator, Project, Rules, Transaction, VulnerabilityIterator
*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Vulnerability: default or custom vulnerabilities on components.
 *
 * Class variables (those prefixed with underscore should not be accessed from outside)
 *	_all: Map of all Vulnerability objects, indexed by id
 *	get(i): returns the object with id 'i' (an element of _all).
 *	autotitle(pid,newtitle): returns a unique (within project with id==pid) name based on newtitle.
 * Instance properties:
 *	id: UUID.
 *	type: one of 'tWLS','tWRD','tEQT'. Actors and unknown links don't have Vulnerabilities.
 *	project: ID of the project to which this threat belongs.
 *	title: short name of the threat.
 *	description: description of the threat.
 *	common: (boolean) true iff the vulnerability is default on new nodes, false for custom vulnerabilities
 * Methods:
 *	destroy: destructor.
 *	settitle(str): sets the short name text to 'str'.
 *	addtablerow(oid): append a table row to HTML element 'oid', including interactions.
 *	setdescription(str): sets the full description text to 'str'.
 *	setcommon(bool): sets whether or not this Vulnerability is default for new nodes.
 *	_stringify: create a JSON text string representing this object's data.
 *	exportstring: return a line of text for insertion when saving this file.
 *	store(): store the object into localStorage.
 *	interncheck(): returns a multi-line string containing errors (one error per line), or empty string on no errors.
 */
class Vulnerability {
	constructor(pid,type,id = createUUID()) {
		if (Vulnerability._all.has(id)) {
			bugreport("Vulnerability with id "+id+" already exists","Vulnerability.constructor");
		}
		this.id = id;
		this.type = type;
		this.project = pid;
		this.title = _("Vulnerability ")+this.id;
		this.description = _("Description of this vulnerability");
		this.common = false;
		
		this.store();
		Vulnerability._all.set(this.id,this);
	}

	static get(id) { return Vulnerability._all.get(id); }
	
	static autotitle(pid,newtitle) {
		if (!newtitle)  newtitle = _("New vulnerability");
		let targettitle = newtitle;
		let n = 0;
		let it = new VulnerabilityIterator({project: pid});
		while (it.some(v => (v.title==targettitle))) {
			targettitle = newtitle + ' (' + (++n) + ')';
		}
		return targettitle;
	}

	destroy() {
		localStorage.removeItem(LS + 'V:' + this.id);
		$('#threat'+this.id).remove();
		Vulnerability._all.delete(this.id);
	}
	
	settitle(t) {
		t = String(t).trim().substr(0,50);
		// Silently ignore a blank title
		if (t=="")  return;

		// See if this title already exists. If so, silently ignore
		var it = new VulnerabilityIterator({project: this.project, type: this.type});
		for (const th of it) {
			if (th.id==this.id) continue;
			if (isSameString(th.title,t))  return;
		}
		// There should be a root cluster with the old title. Change that as well
		it = new NodeClusterIterator({project: this.project, isroot: true, type: this.type});
		for (const nc of it) {
			if (!isSameString(nc.title,this.title))  continue;
			nc.settitle(t);
		}
		this.title = t;
		this.store();
	}

	addtablerow(oid) {
		var snippet = '<div id="threat_TI_" class="threat">\
			<div id="thname_TI_" class="th_col th_name"><span>_TN_</span></div>\
			<div id="thdesc_TI_" class="th_col th_descr"><span>_TD_</span></div>\
			<div class="th_col th_del" title="_DD_"><div id="thdel_TI_" ></div></div>\
			</div>\n';
		snippet = snippet.replace(/_TI_/g, this.id);
		snippet = snippet.replace(/_TT_/g, Rules.nodetypes[this.type]);
		snippet = snippet.replace(/_TN_/g, H(this.title));
		snippet = snippet.replace(/_TD_/g, H(this.description));
		snippet = snippet.replace(/_DD_/g, _("Remove vulnerability"));
		$(oid).append(snippet);
	
		$('#thname'+this.id).editInPlace({
			bg_out: 'var(--vlightbg)', bg_over: 'var(--highlt)',
			callback: function(domid, enteredText) { 
				let vln = Vulnerability.get( nid2id(domid) );
				let it = new VulnerabilityIterator({project: vln.project, type: vln.type, title: enteredText});
				if (it.isEmpty()) {
					new Transaction('vulnDetails',
						[{vuln: vln.id, title: vln.title}],
						[{vuln: vln.id, title: enteredText}],
						_("Rename vulnerability")
					);
				} else {
					let other = it.first();
					if (!other.common) {
						rasterAlert(_("Cannot rename vulnerability"),_H("The title '%%' already exists as a vulnerability in this project.", enteredText));
					}
				}
				return H(vln.title);
			}
		});
		$('#thdesc'+this.id).editInPlace({
			bg_out: 'var(--vlightbg)', bg_over: 'var(--highlt)',
			callback: function(domid, enteredText) { 
				let vln = Vulnerability.get( nid2id(domid) );
				new Transaction('vulnDetails',
					[{vuln: vln.id, description: vln.description}],
					[{vuln: vln.id, description: enteredText}],
					_("Change vulnerability description")
				);
				return H(vln.description);
			}
		});
		$('#thdel'+this.id).button({label: 'âŠ—'}).on('click',  function() {
			let vln = Vulnerability.get(nid2id(this.id));
			newRasterConfirm(_("Delete vulnerability?"),
				_("Do you want to delete the vulnerability '%%' for <i>all current</i> and future %% nodes?", H(vln.title), Rules.nodetypes[vln.type]),
				_("Remove"),_("Cancel")
			)
			.done(function() {
				// To delete a common vulnerability chain two Transactions:
				//  1. delete the Assessment whereever it occurs
				//  2. delete the Vulnerability and its corresponding NodeCluster
				// To undo this action:
				//  1. recreate the Vulnerability and its NodeCluster
				//  2. recreate all Assessments
				let p = Project.get(vln.project);
				let it = new NodeClusterIterator({project: p.id, isroot: true, type: vln.type, title: vln.title});
				if (it.count()!=1) {
					bugreport("No or too many node clusters","common vulnerability delete");
				}
				let cl = it.first();
				let undo_data = {create: true, vuln: vln.id, clid: cl.id, cluster: cl.structure(), assmnt: []};
				let do_data = {create: false, vuln: vln.id, clid: cl.id, assmnt: []};

				it = new AssessmentIterator({vuln: vln.id});
				for (const a of it) {
					if (a.cluster) continue;
					let cm = Component.get(a.component);
					do_data.assmnt.push({id: a.id});
					undo_data.assmnt.push({id: a.id, component: cm.id, freq: a.freq, impact: a.impact, remark: a.remark, index: cm.assmnt.indexOf(a.id)});
				}
				new Transaction('assmCreateDelete', [undo_data], [do_data], '', true);

				do_data = {create: false, id: vln.id};
				undo_data = {create: true, id: vln.id, project: p.id, type: vln.type, title: vln.title, description: vln.description,
					common: true, cluster: cl.id, cla: cl.assmnt, index: p.vulns.indexOf(vln.id)
				};
				new Transaction('vulnCreateDelete', [undo_data], [do_data], _("Remove vulnerability '%%'",vln.title));
			});
		});
	}

	setdescription(t) {
		this.description = String(t).trim().substr(0,100);
		this.store();
	}

	setcommon(b) {
		this.common = (b===true);
		this.store();
	}

	_stringify() {
		var data = {};
		data.t=this.type;
		data.l=this.title;
		data.d=this.description;
		data.p=this.project;
		data.c=this.common;
		return JSON.stringify(data);
	}
	
	exportstring() {
		var key = LS+'V:'+this.id;
		return key + '\t' + this._stringify() + '\n';
	}
	
	store() {
		var key = LS+'V:'+this.id;
		localStorage[key] = this._stringify();
	}

	internalCheck() {
		let errors = "";
		let offender = "Vulnerability '"+H(this.title)+"' ("+this.id+") ";
		let key = LS+'V:'+this.id;
		let lsval = localStorage[key];

		if (!lsval) {
			errors += offender+" is not in local storage.\n";
		}
		if (lsval && lsval!=this._stringify()) {
			errors += offender+" local storage is not up to date.\n";
		}
		
		if (!this.common) {
			let it = new AssessmentIterator({vuln: this.id});
			if (it.isEmpty()) {
				errors += offender+" is custom, but does not have Assessments.\n";
			}
		}
		return errors;
	}
}

Vulnerability._all = new Map();
